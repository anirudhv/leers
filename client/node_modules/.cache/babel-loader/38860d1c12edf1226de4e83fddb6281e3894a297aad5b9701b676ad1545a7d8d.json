{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst mkdirs = require('../mkdirs').mkdirs;\nconst pathExists = require('../path-exists').pathExists;\nconst utimesMillis = require('../util/utimes').utimesMillis;\nconst stat = require('../util/stat');\nfunction copy(src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts;\n    opts = {};\n  } else if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  cb = cb || function () {};\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');\n  }\n  stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err);\n      runFilter(src, dest, opts, (err, include) => {\n        if (err) return cb(err);\n        if (!include) return cb();\n        checkParentDir(destStat, src, dest, opts, cb);\n      });\n    });\n  });\n}\nfunction checkParentDir(destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest);\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err);\n    if (dirExists) return getStats(destStat, src, dest, opts, cb);\n    mkdirs(destParent, err => {\n      if (err) return cb(err);\n      return getStats(destStat, src, dest, opts, cb);\n    });\n  });\n}\nfunction runFilter(src, dest, opts, cb) {\n  if (!opts.filter) return cb(null, true);\n  Promise.resolve(opts.filter(src, dest)).then(include => cb(null, include), error => cb(error));\n}\nfunction getStats(destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat;\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err);\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`));else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));\n    return cb(new Error(`Unknown file: ${src}`));\n  });\n}\nfunction onFile(srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb);\n  return mayCopyFile(srcStat, src, dest, opts, cb);\n}\nfunction mayCopyFile(srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err);\n      return copyFile(srcStat, src, dest, opts, cb);\n    });\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`));\n  } else return cb();\n}\nfunction copyFile(srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err);\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb);\n    return setDestMode(dest, srcStat.mode, cb);\n  });\n}\nfunction handleTimestampsAndMode(srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err);\n      return setDestTimestampsAndMode(srcMode, src, dest, cb);\n    });\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb);\n}\nfunction setDestTimestampsAndMode(srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err);\n    return setDestMode(dest, srcMode, cb);\n  });\n}\nfunction setDestMode(dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb);\n}\nfunction setDestTimestamps(src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err);\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);\n  });\n}\nfunction onDir(srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);\n  return copyDir(src, dest, opts, cb);\n}\nfunction mkDirAndCopy(srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err);\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err);\n      return setDestMode(dest, srcMode, cb);\n    });\n  });\n}\nfunction copyDir(src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err);\n    return copyDirItems(items, src, dest, opts, cb);\n  });\n}\nfunction copyDirItems(items, src, dest, opts, cb) {\n  const item = items.pop();\n  if (!item) return cb();\n  return copyDirItem(items, item, src, dest, opts, cb);\n}\nfunction copyDirItem(items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  runFilter(srcItem, destItem, opts, (err, include) => {\n    if (err) return cb(err);\n    if (!include) return copyDirItems(items, src, dest, opts, cb);\n    stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {\n      if (err) return cb(err);\n      const {\n        destStat\n      } = stats;\n      getStats(destStat, srcItem, destItem, opts, err => {\n        if (err) return cb(err);\n        return copyDirItems(items, src, dest, opts, cb);\n      });\n    });\n  });\n}\nfunction onLink(destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err);\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n    }\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb);\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb);\n          return cb(err);\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest);\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));\n        }\n        return copyLink(resolvedSrc, dest, cb);\n      });\n    }\n  });\n}\nfunction copyLink(resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err);\n    return fs.symlink(resolvedSrc, dest, cb);\n  });\n}\nmodule.exports = copy;","map":{"version":3,"names":["fs","require","path","mkdirs","pathExists","utimesMillis","stat","copy","src","dest","opts","cb","filter","clobber","overwrite","preserveTimestamps","process","arch","emitWarning","checkPaths","err","stats","srcStat","destStat","checkParentPaths","runFilter","include","checkParentDir","destParent","dirname","dirExists","getStats","Promise","resolve","then","error","dereference","lstat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","mayCopyFile","unlink","errorOnExist","handleTimestampsAndMode","mode","setDestMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestampsAndMode","setDestTimestamps","chmod","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","mkdir","readdir","items","copyDirItems","item","pop","copyDirItem","srcItem","join","destItem","readlink","resolvedSrc","cwd","symlink","resolvedDest","code","isSrcSubdir","copyLink","module","exports"],"sources":["C:/Users/aniru/Documents/leers/node_modules/fs-extra/lib/copy/copy.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      runFilter(src, dest, opts, (err, include) => {\n        if (err) return cb(err)\n        if (!include) return cb()\n\n        checkParentDir(destStat, src, dest, opts, cb)\n      })\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return getStats(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return getStats(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction runFilter (src, dest, opts, cb) {\n  if (!opts.filter) return cb(null, true)\n  Promise.resolve(opts.filter(src, dest))\n    .then(include => cb(null, include), error => cb(error))\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))\n    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))\n    return cb(new Error(`Unknown file: ${src}`))\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  runFilter(srcItem, destItem, opts, (err, include) => {\n    if (err) return cb(err)\n    if (!include) return copyDirItems(items, src, dest, opts, cb)\n\n    stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {\n      if (err) return cb(err)\n      const { destStat } = stats\n      getStats(destStat, srcItem, destItem, opts, err => {\n        if (err) return cb(err)\n        return copyDirItems(items, src, dest, opts, cb)\n      })\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}